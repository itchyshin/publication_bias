---
title: "Figures3456"
author: "Shinichi Nakagawa"
date: "21/01/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# loading pakcages we need
library(tidyverse)
library(patchwork)
library(cowplot)
library(metafor)
library(metaviz)
library(meta)
library(ggplotify)
library(grid)
library(dmetar)
library(viridis)
```


#### creating data

```{r}

set.seed(77777)

# setting parameters
n.effect <- 100
sigma2.s <- 0.05
beta1 <- 0.2
# using negative binomial we get good spread of sample size
n.sample <- rnbinom(n.effect, mu = 30, size = 0.7) + 4
# variance for Zr
vi <- 1/(n.sample - 3)
# moderator x 1
xi <- rnorm(n.effect)

# there is underling overall effect to r = 0.2 or Zr = 0.203
Zr <- atanh(0.2) + beta1*xi + rnorm(n.effect, 0, sqrt(sigma2.s)) + rnorm(n.effect, 0, sqrt(vi))
qplot(Zr, 1/sqrt(vi))

dat <- data.frame(yi = Zr, vi = vi, sei = sqrt(vi), xi = xi, ni = n.sample, prec = 1 / sqrt(vi), wi = 1/vi, zi = Zr/sqrt(vi))

rows <- 1:nrow(dat)
expected <- which(1/dat$sei < 5 & dat$yi < 0.25)
unexpected <- which(1/dat$sei > 4.7 & dat$yi > 0.25)

col_point <- ifelse(rows %in% expected, "red", ifelse(rows %in% unexpected, "blue", "black"))

dat$col_point <- col_point

#col_pch <- ifelse(col_point == "black", 16, 21)
```

### fig 3

```{r}

#https://stackoverflow.com/questions/50012553/combining-plots-created-by-r-base-lattice-and-ggplot2
# saving base plot as an object!!! https://www.andrewheiss.com/blog/2016/12/08/save-base-graphics-as-pseudo-objects-in-r/

mod_ra <- rma(yi, vi, data = dat)
mod_fe <- rma(yi, vi, data = dat, method = "FE")

# margin controlling
#par(mar=c(5,4,0,0) + 0.1)

#TODO - DL for sunset plot and enhanced counter - making it - 0.01 < p < 0.05 

# a
pdf(NULL)
dev.control(displaylist="enable")
par(mar=c(4,4,0.1,0) + 0.1)
funnel(dat$yi, dat$vi, ni = dat$ni, yaxis="ni",
       xlim = c(-3, 3),
       refline=mod_ra$beta, xlab = "Effect size (Zr)") 
a <- recordPlot()
invisible(dev.off())

# # b
# pdf(NULL)
# dev.control(displaylist="enable")
# par(mar=c(4,4,0.1,0) + 0.1)
# funnel(mod_ra, yaxis="seinv", ylim = c(1, 12),
#        ylab = "Precison (1/SE)", xlab = "Effect size (Zr)")
# b <- recordPlot()
# invisible(dev.off())


# b
pdf(NULL)
dev.control(displaylist="enable")
par(mar=c(4,4,0.1,0) + 0.1)
funnel(mod_ra, yaxis="seinv", col = col_point,  
       ylim = c(1, 12), xlim = c(-3, 3),
       ylab = "Precison (1/SE)", xlab = "Effect size (Zr)")
legend(x = 1.4, y = 12, legend = c("expected", "","unexpected"), pch = c(19, 0, 19), col = c("red", "grey83", "blue"), bty = "n")
b <- recordPlot()
invisible(dev.off())

# funnel(mod_ra, yaxis="seinv", col = col_point,  
#        ylim = c(1, 12), xlim = c(-3, 3),
#        ylab = "Precison (1/SE)", xlab = "Effect size (Zr)")
# legend(x = c(1.4, 3.2), y = c(10, 12), legend = c("expected", "", "unexpected", ""), pch = c(19, 0, 19, 0), col = c("red", "white", "blue", "white"),
#        bg = "white")

# c
# pdf(NULL)
# dev.control(displaylist="enable")
# par(mar=c(4,4,0.1,0) + 0.1)
# funnel(mod_ra, yaxis="sei", ylab = "Standard error (SE)", xlab = "Effect size (Zr)")
# c <- recordPlot()
# invisible(dev.off())


# c
pdf(NULL)
dev.control(displaylist="enable")
par(mar=c(4,4,0.1,0) + 0.1)
funnel(mod_ra, 
       yaxis = "sei", 
       xlim = c(-3, 3),
       level = c(95, 99), 
       shade = c("white", "gray55"), 
       refline = 0, legend = F, 
       ylab = "Standard error (SE)", xlab = "Effect size (Zr)")
legend(x = 1, y = 0, legend = c("0.01 < p < 0.05"), pch = c(15), col = c("gray55"), bty = "n")
c <- recordPlot()
invisible(dev.off())

# d
d <- viz_sunset(dat[,c("yi", "sei")], 
           power_contours = "continuous", 
           contours = T,
           power_stats = F,
           xlab = "Effect size (Zr)",
           ylab = "Standard error (SE)")


# e
# meta-regression (random-effects model)
mod_re1 <- rma(yi, vi, mod = ~ xi, data = dat)

# pdf(NULL)
# dev.control(displaylist="enable")
# par(mar=c(4,4,0.1,0) + 0.1)
# funnel(mod_re1, yaxis="seinv",  ylim = c(1, 5),
#        ylab = "Precison (1/SE)", xlab = "Standardized residuals (Zr)") 
# e <- recordPlot()
# invisible(dev.off())


pdf(NULL)
dev.control(displaylist="enable")
par(mar=c(4,4,0.1,0) + 0.1)
funnel(mod_re1, 
       yaxis = "sei", 
       xlim = c(-3, 3), ylim = c(0, 1),
       #level = c(95, 99), 
       #shade = c("white", "gray75"), 
       refline = 0, legend = F,  ylab = "Standard error (SE)", xlab = "Standardized residuls (Zr)")
#legend(x = 1, y = 0, legend = c("0.01 < p < 0.05", ""), pch = c(15, 0), col = c("gray75", "white"), bg = "white")
e <- recordPlot()
invisible(dev.off())

# f

# 
mod <- metagen(TE = yi, seTE = sqrt(vi) , data = dat)

pdf(NULL)
dev.control(displaylist="enable")
par(mar=c(4,4,0.1,0) + 0.1)
#radial.rma(mod_fe, xlim = c(0, 12.5), zlab = "Z score", xlab = "Precision (1/SE)") 
#legend(1,1, "test", bty = "n")
radial(mod, level = 0.95, pch = 19,  xlab = "Precision (1/SE)", ylab = "Z score")
#abline(a = 0, b = 0.1908, lwd = 1.5)
f <- recordPlot()
invisible(dev.off())

fig3 <- (ggdraw(a) + ggdraw(b)) /(ggdraw(c) + ggdraw(d))/ (plot_grid(e) + ggdraw(f)) + plot_annotation(tag_levels = 'a')

fig3
```


### fig 4

#### data creation

```{r}

dat2 <- dat[dat$col_point != "red", ]

mod_ra2 <- rma(yi, vi, data = dat2)


regtest(mod_ra2, model = "lm")

# they are the same
egger1 <- lm(zi ~ prec, data = dat2)
egger2 <- lm(yi ~ sei, weight = wi, data = dat2)

summary(egger1)
summary(egger2)

# plot

with(dat2, plot(prec, zi))
with(dat2, plot(sei, yi))
#with(dat2, plot(vi, yi))

# tidyverse

p1 <-  ggplot(dat2, aes(prec, zi)) + geom_point() +
        geom_hline(yintercept = 0, linetype = "dashed") + 
        geom_hline(yintercept = egger1$coefficients[[1]]) +
        #geom_smooth(method = "lm") + 
        labs(x = "Precision (1/SE)", 
       y = "Z score")

p2 <- ggplot(dat2, aes(sei, yi)) + geom_point() +
       # geom_smooth(method = "lm") + 
        geom_hline(yintercept = 0, linetype = "dashed") + 
        geom_abline(intercept = egger2$coefficients[[1]], slope = egger2$coefficients[[2]])
        labs(x = "Standard error (SE)", 
       y = "Effect size (Zr)")


# ggplot(dat2, aes(vi, yi)) + geom_point() +
#         geom_smooth(method = "lm") + 
#         labs(x = "Sampling varinace", 
#        y = "Effect size (Zr)")

# pick up 
        
set.seed(123)
position <- sample(1:nrow(dat2), size = 15)

dat3 <- dat2[sort(position), ]

sorting <- c(12, 13, 14, 3, 4, 9, 8, 5, 10, 11,  6, 7, 2, 15, 1)

dat3 <- dat3[sorting, ]        
dat3$year <- c(2000, 2001, 2003, 2005, 2006, 2007, 2008, 2009, 2010, 2012, 2013, 2014, 2016, 2018, 2019)

# cumlatie meta-analysis

cum <- rma(yi, vi, data=dat3)
cum_ma <- cumul(cum)
forest(cum_ma, xlab = "Overall estimate (Zr)")


# meta-regression

mod_re2 <- rma(yi, vi, mod = ~ year, data = dat3)

p4 <- ggplot(dat3, aes(x = year, y = yi, size = prec)) +
         geom_hline(yintercept = 0, linetype = "dashed") + 
        geom_abline(intercept = mod_re2$beta[[1]], slope = mod_re2$beta[[2]]) +
 geom_point(shape = 21, fill = "grey90") + 
        labs(x = "Publication year", y = "Effect size (Zr)", size ="Precision (1/SE)") + 
        guides(fill = "none", colour = "none") +
  theme(legend.position = c(0, 0.1), legend.justification = c(0, 1)) +
  theme(legend.direction = "horizontal") +
  # theme(legend.background = element_rect(fill = "white", colour = "black")) +
  theme(legend.background = element_blank()) +
  theme(axis.text.y = element_text(size = 10, colour = "black", hjust = 0.5, angle = 90))

# funnel

taf <- trimfill(mod_ra2)

```



```{r}
# a and b
# more data for this 100???


p1 <-  ggplot(dat2, aes(prec, zi)) + geom_point() +
        geom_hline(yintercept = 0, linetype = "dashed") + 
        geom_hline(yintercept = egger1$coefficients[[1]]) +
        #geom_smooth(method = "lm") + 
        labs(x = "Precision (1/SE)", 
       y = "Z score")

p2 <- ggplot(dat2, aes(sei, yi)) + geom_point() +
       # geom_smooth(method = "lm") + 
        geom_hline(yintercept = 0, linetype = "dashed") + 
        geom_abline(intercept = egger2$coefficients[[1]], slope = egger2$coefficients[[2]]) +
        labs(x = "Standard error (SE)", 
       y = "Effect size (Zr)")

# c and d
# probably 15 data points for cumlative meta-analyses

cum <- rma(yi, vi, data=dat3)
cum_ma <- cumul(cum)

# p3
pdf(NULL)
dev.control(displaylist="enable")
par(mar=c(4,4,0.1,0) + 0.1)
forest(cum_ma, xlab = "Overall estimate (Zr)")
p3 <- recordPlot()
invisible(dev.off())

p4 <- ggplot(dat3, aes(x = year, y = yi, size = prec)) +
         geom_hline(yintercept = 0, linetype = "dashed") + 
        geom_abline(intercept = mod_re2$beta[[1]], slope = mod_re2$beta[[2]]) +
 geom_point(shape = 21, fill = "grey90") + 
        labs(x = "Publication year", y = "Effect size (Zr)", size ="Precision (1/SE)") + 
        guides(fill = "none", colour = "none") +
  theme(legend.position = c(0, 0.15), legend.justification = c(0, 1)) +
  theme(legend.direction = "horizontal") +
  # theme(legend.background = element_rect(fill = "white", colour = "black")) +
  theme(legend.background = element_blank()) +
  theme(axis.text.y = element_text(size = 10, colour = "black", hjust = 0.5, angle = 90))

# p5
pdf(NULL)
dev.control(displaylist="enable")
par(mar=c(4,4,0.1,0) + 0.1)
funnel(taf, yaxis="seinv", col = col_point,  estimator="R0",
       ylim = c(1, 12), 
       #xlim = c(-3, 3),
       ylab = "Precison (1/SE)", xlab = "Effect size (Zr)")
p5 <- recordPlot()
invisible(dev.off())

# p6
pdf(NULL)
dev.control(displaylist="enable")
par(mar=c(4,4,0.1,0) + 0.1)
funnel(taf, yaxis="sei", col = col_point,  estimator="R0",
       #xlim = c(-3, 3),
       ylab = "Standard error (SE)", xlab = "Effect size (Zr)")
p6 <- recordPlot()
invisible(dev.off())


# e and f
# maybe use the same datasets as Fig 3

fig4 <- (plot_grid(p1) + plot_grid(p2)) /(ggdraw(p3) + plot_grid(p4))/(plot_grid(p5) + plot_grid(p6)) + plot_annotation(tag_levels = 'a')

fig4

```



### fig 5

# dmetr

```{r}
#devtools::install_github("MathiasHarrer/dmetar")
library(dmetar)

p_dat <- data.frame("studlab" = as.factor(1:nrow(dat2)), "TE" = dat2$yi, "seTE" = dat2$sei)
pcurve(p_dat)

pdf(NULL)
dev.control(displaylist="enable")
par(mar=c(4,4,0.1,0) + 0.1)
pcurve(p_dat)
plot<- recordPlot()
invisible(dev.off())

# turuning the base plot into ggplot
plot <- ggdraw(plot)



```

# metafor selection model

```{r}

dat2

model <- rma(yi, vi = vi, data = dat2, method = "ML", mod = ~ xi)

#sel0 <- selmodel(model, type = "beta")
sel1 <- selmodel(model, type="halfnorm", prec="sei", scaleprec=FALSE)
sel2 <- selmodel(model, type="negexp",   prec="sei", scaleprec=FALSE)
sel3 <- selmodel(model, type="logistic", prec="sei", scaleprec=FALSE)
sel4 <- selmodel(model, type="power",    prec="sei",  scaleprec=FALSE)
sel1b <- selmodel(model, type="halfnorm")
sel2b <- selmodel(model, type="negexp")
sel3b <- selmodel(model, type="logistic")
sel4b <- selmodel(model, type="power")

# plot selection functions

# normal, exponentail, logistic or power

plot(sel1)
plot(sel2, add=TRUE, col="blue")
#plot(sel3, add=TRUE, col="red")
plot(sel4, add=TRUE, col="green")
plot(sel1b, add=TRUE, lty = "dotted")
plot(sel2b, add=TRUE, col="blue", lty = "dotted")
#plot(sel3b, add=TRUE, col="red", lty = "dotted")
plot(sel4b, add=TRUE, col="green", lty = "dotted")

# step function 
sel5 <- selmodel(model, type="stepfun", steps=c(0.05, 0.10, 0.50, 1.00))
sel6 <- selmodel(model, type="stepfun", steps=c(0.001, 0.01, 0.05, 0.10, 0.25, 0.50, 0.75, 1))
sel7 <- selmodel(model, type="stepfun", steps=c(0.05, 1))

plot(sel5, ylim = c(0,1))
#plot(sel6, add=TRUE, col="red", scale = T)
plot(sel7, add=TRUE, col="red")
legend(x = 0.5, y = 1, legend = c("3 cutpoints", "","1 cutpoint (3 PMS)"), lty =c(1, 0, 1), col = c("black", "", "red"), bty = "n")

```

#### ploting

```{r}
# A 

pA <- plot +  theme(plot.margin=unit(c(-1,0,-1,0),"cm"))

# B
pdf(NULL)
dev.control(displaylist="enable")
par(mar=c(4,4,0.1,0) + 0.1)
plot(sel1)
plot(sel3, add=TRUE, col="red")
plot(sel1b, add=TRUE, lty = "dotted")
plot(sel3b, add=TRUE, col="red", lty = "dotted")
legend(x = 0.6, y = 1, legend = c("half-normal", "","logistic"), lty =c(1, 0, 1), col = c("black", "", "red"), bty = "n")
pB <- recordPlot()
invisible(dev.off())

# C
pdf(NULL)
dev.control(displaylist="enable")
par(mar=c(4,4,0.1,0) + 0.1)
plot(sel5, ylim = c(0,1))
plot(sel7, add=TRUE, col="red", lty = 3)
legend(x = 0.5, y = 1, legend = c("3 cutpoints", "","1 cutpoint (3 PSM)"), lty =c(1, 0, 1), col = c("black", "", "red"), bty = "n")
pC <- recordPlot()
invisible(dev.off())


fig5 <- pA /(ggdraw(pB) + ggdraw(pC)) + plot_annotation(tag_levels = 'a')

fig5

```



### fig 6 

#### data creation
##### Zr data

```{r}

# Zr -- data

# 25 studies 
# data from 1 to 6 
# 100 effect size

set.seed(777)
# setting parameters
n.study  <- 70
sigma2.s <- 0.05
sigma2.u <- 0.05
beta1 <- 0.1
beta2 <- - 0.05
# using negative binomial we get good spread of sample size
n.sample <- rnbinom(n.study, mu = 30, size = 0.2) + 4

# the number of effect size per study
set.seed(777777)
n.es.per.s <- rpois(n.study,3) + 1
sum(n.es.per.s)

n.effect <- sum(n.es.per.s)
# variance for Zr
vi <- 1/(rep(n.sample, n.es.per.s) - 3)



# In the text, we have two moderators
# moderator x 1 - study level
x1j <- rnorm(n.study)
# moderator x 2 - effect isze level
x2i <- rnorm(n.effect)

# study position

place <- rep(1:n.study, n.es.per.s)

# there is underling overall effect to r = 0.3 or Zr = 0.3095196
Zr <- 0 + rnorm(n.study, 0, sqrt(sigma2.s))[place] + 
        rnorm(n.effect, 0, sqrt(sigma2.u)) + rnorm(n.effect, 0, sqrt(vi))

#qplot(Zr, 1/sqrt(vi))

datA <- data.frame(yi = Zr, vi = vi, sei = sqrt(vi), x1 = x1j[place], x2 = x2i, ni = n.sample[place], prec = 1 / sqrt(vi), wi = 1/vi, zi = Zr/sqrt(vi), studyID = place, effectID = 1:n.effect)


# cutting publication mbias like stuff
expected <- c(which(1/datA$sei < 5.5 & datA$yi < 0.2), which(1/datA$sei < 3 & datA$yi < 0.7))

datB <- datA[-expected, ]

qplot(x = yi, y = 1/sqrt(vi), data = datB)

mod_ma <- rma.mv(yi, vi, mod = ~ sqrt(vi), random = list(~ 1 | studyID, ~1 | effectID), data = datB)

mod_mb <- rma.mv(yi, vi, mod = ~ vi, random = list(~ 1 | studyID, ~1 | effectID), data = datB)

summary(mod_ma)
summary(mod_mb)
#

# creatomg curve lines
x = seq(0, 1, by = 0.001)
y =  mod_mb$beta[[1]] + sqrt(x)* mod_mb$beta[[2]]

vi_curve <- tibble(x = x, y = y)

# E

# SE
ggplot(datB, aes(sei, yi)) + geom_point() + 
        geom_line(data = vi_curve, mapping = aes(x = x, y = y, col = "red")) +
        #geom_point(aes(col = studyID)) +
       # geom_smooth(method = "lm") + 
        geom_hline(yintercept = 0, linetype = "dashed") + 
        geom_abline(intercept = mod_ma$beta[[1]], slope = mod_ma$beta[[2]]) +
        xlim(0, 1) + ylim(-1.5, 2.5) + 
        labs(x = "Standard error (SE)", y = "Effect size (Zr)")+ 
        theme(legend.position = "none")
# F

# Variance
ggplot(datB, aes(vi, yi)) + geom_point() + 
        #geom_point(aes(col = studyID)) +
       # geom_smooth(method = "lm") + 
        geom_hline(yintercept = 0, linetype = "dashed") + 
        geom_abline(intercept = mod_mb$beta[[1]], slope = mod_mb$beta[[2]], col = "red") +
        xlim(0, 1) + ylim(-1.5, 2.5) + 
        labs(x = "Sampling variance", y = "Effect size (Zr)")

#mod_re3 <- rma.mv(yi, vi, mod = ~ x1 + x2, random = list(~ 1 | studyID, ~1 | effectID), data = dat2)

```

##### lnRR data

```{r}
# function to make a matix for corelated sampling error

make_VCV_matrix <- function(data, V, cluster, obs, type=c("vcv", "cor"), rho=0.5){
  type <- match.arg(type)
  if (missing(data)) {
    stop("Must specify dataframe via 'data' argument.")
  }
  if (missing(V)) {
    stop("Must specify name of the variance variable via 'V' argument.")
  }
  if (missing(cluster)) {
    stop("Must specify name of the clustering variable via 'cluster' argument.")
  }
  if (missing(obs)) {
    obs <- 1:length(V)   
  }
  if (missing(type)) {
    type <- "vcv" 
  }
  
  new_matrix <- matrix(0,nrow = dim(data)[1],ncol = dim(data)[1]) #make empty matrix of the same size as data length
  rownames(new_matrix) <- data[ ,obs]
  colnames(new_matrix) <- data[ ,obs]
  # find start and end coordinates for the subsets
  shared_coord <- which(data[ ,cluster] %in% data[duplicated(data[ ,cluster]), cluster]==TRUE)
  # matrix of combinations of coordinates for each experiment with shared control
  combinations <- do.call("rbind", tapply(shared_coord, data[shared_coord,cluster], function(x) t(utils::combn(x,2))))
  
  if(type == "vcv"){
    # calculate covariance values between  values at the positions in shared_list and place them on the matrix
    for (i in 1:dim(combinations)[1]){
      p1 <- combinations[i,1]
      p2 <- combinations[i,2]
      p1_p2_cov <- rho * sqrt(data[p1,V]) * sqrt(data[p2,V])
      new_matrix[p1,p2] <- p1_p2_cov
      new_matrix[p2,p1] <- p1_p2_cov
    }
    diag(new_matrix) <- data[ ,V]   #add the diagonal
  }
  
  if(type == "cor"){
    # calculate covariance values between  values at the positions in shared_list and place them on the matrix
    for (i in 1:dim(combinations)[1]){
      p1 <- combinations[i,1]
      p2 <- combinations[i,2]
      p1_p2_cov <- rho
      new_matrix[p1,p2] <- p1_p2_cov
      new_matrix[p2,p1] <- p1_p2_cov
    }
    diag(new_matrix) <- 1   #add the diagonal of 1
  }
  
  return(new_matrix)
}
```



```{r}

# lnRR
# 25 studies 
# data from 1 to 6 
# 100 effect size

set.seed(777)
# setting parameters
n.study  <- 30
sigma2.s <- 0.01
sigma2.u <- 0.005
beta1 <- 0.1
beta2 <- -0.01
# using negative binomial we get good spread of sample size
n.sample <- rnbinom(n.study, mu = 40, size = 0.5) + 4


# the number of effect size per study
set.seed(7777)
n.es.per.s <- rpois(n.study,3) + 1
sum(n.es.per.s)

# sample size
n.effect <- sum(n.es.per.s)

# cv for each study

cv <- sample(seq(0.3, 0.35,by = 0.001), n.effect, replace = T)

rep_sample <- rep(n.sample, times = n.es.per.s)

# variance for lnRR
vi <- (2*cv^2)/rep_sample



# In the text, we have two moderators
# moderator x 1 - study level
x1j <- rnorm(n.study)
# moderator x 2 - effect isze level
x2i <- rnorm(n.effect)

# study position

pos <- rep(1:n.study, n.es.per.s)

# there is underling overall effect to lnRR = 0.2

dat3 <- data.frame(vi = vi, sei = sqrt(vi), x1 = x1j[pos], x2 = x2i, ni = n.sample[pos], prec = 1 / sqrt(vi), wi = 1/vi, studyID = pos, effectID = 1:n.effect)

# M matrix (V = VCV)
sigma <- make_VCV_matrix(dat3, "vi", "studyID", "effectID", rho = 0)

lnRR<- 0.3 + beta1*x1j[pos] + beta2*x2i + rnorm(n.study, 0, sqrt(sigma2.s))[pos] + 
        rnorm(n.effect, 0, sqrt(sigma2.u)) +  MASS::mvrnorm(1, rep(0, n.effect), sigma)
        #rnorm(n.effect, 0, sqrt(vi))

#qplot(lnRR, 1/sqrt(vi))

# dat3 <- data.frame(yi = lnRR, vi = vi, sei = sqrt(vi), x1 = x1j[pos], x2 = x2i, ni = n.sample[pos], prec = 1 / sqrt(vi), wi = 1/vi, zi = lnRR/sqrt(vi), studyID = pos, effectID = 1:n.effect)

dat3$yi <- lnRR

# Panel A
mod1 <- rma(yi, vi, data = dat3)
funnel(mod1, col =inferno(25)[pos],
      ylim = c(0, 0.26), xlim = c(-0.6, 0.8),
        ylab = "Standard error (SE)", xlab = "Effect size (Zr)")
#funnel(mod1, yaxis="seinv", col =inferno(25)[pos] )

mod_ml <- rma.mv(yi, vi, mod = ~ x1 + x2, random = list(~ 1 | studyID, ~1 | effectID), data = dat3)

# residuals - stadnarised
summary(mod_ml)
#funnel(mod_ml, yaxis="seinv", col = inferno(25)[pos])


# residual marginal
residm <- dat3$yi - predict(mod_ml)[[1]]
vi_residm <- vi + predict(mod_ml)[[2]]^2 # adding prediction errors 

# Panel B
funnel (residm, vi = vi_residm, yaxis = "sei",  col = inferno(25)[pos],  
        ylim = c(0, 0.26), xlim = c(-0.6, 0.8),
        ylab = "Standard error (SE)", xlab = "Residuals marginal (lnRR)")


# residual conditional 1 & 2 + its error

blups <- ranef(mod_ml)

study_effect <- blups$studyID[[1]][pos]
vi_study <- (blups$studyID[[2]][pos])^2

residc1 <- dat3$yi - (predict(mod_ml)[[1]] + study_effect)
vi_residc1 <- vi_residm + vi_study

effect_effect <- blups$effectID[[1]]
vi_effect <- blups$effectID[[1]]^2

residc2 <- dat3$yi - (predict(mod_ml)[[1]] + study_effect + effect_effect)
vi_residc2 <- vi_residm + vi_study + vi_effect


# Panel C
funnel(residc1, vi = vi_residc1, yaxis = "sei",  col = inferno(25)[pos],
       ylim = c(0, 0.26), xlim = c(-0.6, 0.8),
        ylab = "Standard error (SE)", xlab = "Residuals conditional 1 (lnRR)")

# Panel D
funnel(residc2, vi = vi_residc2, yaxis = "sei",  col = inferno(25)[pos],
       ylim = c(0, 0.26), xlim = c(-0.6, 0.8),
        ylab = "Standard error (SE)", xlab = "Residuals conditional 2 (lnRR)")

#



```


#### plotting
```{r}

# Panel A
pdf(NULL)
dev.control(displaylist="enable")
par(mar=c(4,4,0.1,0) + 0.1)
funnel(mod1, col =inferno(25)[pos],
      ylim = c(0, 0.26), xlim = c(-0.6, 0.8),
        ylab = "Standard error (SE)", xlab = "Effect size (lnRR)")
pa <- recordPlot()
invisible(dev.off())

# Panel B
pdf(NULL)
dev.control(displaylist="enable")
par(mar=c(4,4,0.1,0) + 0.1)
funnel (residm, vi = vi_residm, yaxis = "sei",  col = inferno(25)[pos],  
        ylim = c(0, 0.26), xlim = c(-0.6, 0.8),
        ylab = "Standard error (SE)", xlab = "Residuals marginal (lnRR)")
pb <- recordPlot()
invisible(dev.off())

# Panel C
pdf(NULL)
dev.control(displaylist="enable")
par(mar=c(4,4,0.1,0) + 0.1)
funnel(residc1, vi = vi_residc1, yaxis = "sei",  col = inferno(25)[pos],
       ylim = c(0, 0.26), xlim = c(-0.6, 0.8),
        ylab = "Standard error (SE)", xlab = "Residuals conditional 1 (lnRR)")
pc <- recordPlot()
invisible(dev.off())

# Panel D
pdf(NULL)
dev.control(displaylist="enable")
par(mar=c(4,4,0.1,0) + 0.1)
funnel(residc2, vi = vi_residc2, yaxis = "sei",  col = inferno(25)[pos],
       ylim = c(0, 0.26), xlim = c(-0.6, 0.8),
        ylab = "Standard error (SE)", xlab = "Residuals conditional 2 (lnRR)")
pd <- recordPlot()
invisible(dev.off())

# Panel E
pe <- ggplot(datB, aes(sei, yi)) + geom_point() + 
        geom_line(data = vi_curve, mapping = aes(x = x, y = y, col = "red")) +
        #geom_point(aes(col = studyID)) +
       # geom_smooth(method = "lm") + 
        geom_hline(yintercept = 0, linetype = "dashed") + 
        geom_abline(intercept = mod_ma$beta[[1]], slope = mod_ma$beta[[2]]) +
        xlim(0, 1) + ylim(-1.5, 2.5) + 
        labs(x = "Standard error (SE)", y = "Effect size (Zr)")+ 
        theme(legend.position = "none")
# F

# Variance
pf <- ggplot(datB, aes(vi, yi)) + geom_point() + 
        #geom_point(aes(col = studyID)) +
       # geom_smooth(method = "lm") + 
        geom_hline(yintercept = 0, linetype = "dashed") + 
        geom_abline(intercept = mod_mb$beta[[1]], slope = mod_mb$beta[[2]], col = "red") +
        xlim(0, 1) + ylim(-1.5, 2.5) + 
        labs(x = "Sampling variance", y = "Effect size (Zr)")

fig6 <- (ggdraw(pa) + ggdraw(pb)) /(ggdraw(pc) + ggdraw(pd))/(plot_grid(pe) + plot_grid(pf)) + plot_annotation(tag_levels = 'a')

fig6

```


#######################
#######################
### Using `metafor`

```{r}

mod_ra <- rma(yi, vi, data = dat)
mod_fe <- rma(yi, vi, data = dat, method = "FE")

panel_a <- funnel(dat$yi, dat$vi, ni = dat$ni, yaxis="ni", refline=mod_ra$beta, xlab = "Effect size (Zr)")
panel_b <- funnel(mod_ra, yaxis="seinv", ylab = "Precison (1/SE)", xlab = "Effect size (Zr)")
panel_c <- funnel(mod_ra, yaxis="sei", ylab = "Standard error (SE)", xlab = "Effect size (Zr)")
panel_d <- ~funnel(mod_ra, 
       yaxis = "seinv", 
       level = c(90, 95, 99), 
       shade = c("white", "gray55", "gray75"), 
       refline = 0, legend = TRUE,
       ylab = "Precision (1/SE)", xlab = "Effect size (Zr)")
## testing
# the mean is from random-effects model
funnel(mod_ra, yaxis="seinv") # this works with ggdraw(p1)

# saving base plot as an object!!! https://www.andrewheiss.com/blog/2016/12/08/save-base-graphics-as-pseudo-objects-in-r/
pdf(NULL)
dev.control(displaylist="enable")
funnel(mod_ra, yaxis="seinv", col = col_point)
legend(x = 1.5, y = 12, legend = c("expected", "unexpected"), pch = 19, col = c("red", "blue"),
       bg = "white")
panel_f <- recordPlot()
invisible(dev.off())

ggdraw(panel_f)

funnel(mod_ra, yaxis="sei")
#funnel(mod_fe, yaxis="sei")
funnel(dat$yi, dat$vi, ni = dat$ni, yaxis="ni", refline=mod_ra$beta, xlab = "Effect size (Zr)")

# contour enhanced plot
funnel(mod_ra, 
       yaxis = "sei", 
       level = c(90, 95, 99), 
       shade = c("white", "gray55", "gray75"), 
       refline = 0, legend = TRUE)


# contour enhanced plot
funnel(mod_ra, 
       yaxis = "seinv", 
       level = c(90, 95, 99), 
       shade = c("white", "gray55", "gray75"), 
       refline = 0, legend = TRUE)



# the mean annd CI is from fixed effect model
radial(mod_fe, xlim = c(0,12.5)) # this looks a bit too narrow

# meta-regression

mod_re1 <- rma(yi, vi, mod = ~ xi, data = dat)

se_ra <- sqrt(dat$vi + (mod_re1$se[1])^2 + (xi^2*mod_re1$se[2])^2 )

funnel(mod_re1, yaxis="seinv") # this works with ggdraw(p1)
funnel(mod_re1, yaxis="seinv", type = "rstudent")
funnel(mod_re1, yaxis="sei")

mod_re2 <- rma(yi, vi, mod = ~ xi, data = dat, method = "FE")

funnel(mod_re2, yaxis="seinv") # this works with ggdraw(p1)
funnel(mod_re2, yaxis="sei")

```



### Using `meta`
```{r}
mod <- metagen(TE = yi, seTE = sqrt(vi) , data = dat)
radial(mod, level = 0.95, xlab = "Precision (1/SE)", ylab = "Z score")
```


### Using `metaviz`

```{r}


panel_e <- viz_sunset(dat[,c("yi", "sei")], 
           power_contours = "continuous", 
           method = "DL",
           contours = T,
           power_stats = F)


## testing
help(package = "metaviz")

# funnel plots
viz_funnel(dat[,c("yi", "sei")],
           detail_level = 2)

viz_funnel(dat[,c("yi", "sei")], 
           y_axi = "precision",
           method = "DL",
           sig_contours = F,
           contours_col = "Greys",
           xlab = "Zr (Effect size)") +
        


viz_funnel(dat[,c("yi", "sei")], 
           y_axi = "se",
           method = "DL",
           contours_col = "Greys",
           xlab = "Zr (Effect size)")

#sunset
viz_sunset(dat[,c("yi", "sei")], 
           power_contours = "continuous", 
           method = "DL",
           contours = T,
           power_stats = F)


```



### combining all together

How to combine base, lattice and ggplot - https://stackoverflow.com/questions/50012553/combining-plots-created-by-r-base-lattice-and-ggplot2



